import { Test, TestingModule } from '@nestjs/testing';
import { HumanReviewService } from './human-review.service';
import { Repository } from 'typeorm';
import { getRepositoryToken } from '@nestjs/typeorm';
import { ReviewItem } from './entities/review-item.entity';
import { QualityAssessment, QualityFlag } from '../ai/quality-assessment.types';

describe('HumanReviewService', () => {
  let service: HumanReviewService;
  let reviewRepository: Repository<ReviewItem>;

  const mockReviewRepository = {
    create: jest.fn(),
    save: jest.fn(),
    find: jest.fn(),
    findOne: jest.fn(),
    createQueryBuilder: jest.fn(),
  };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        HumanReviewService,
        {
          provide: getRepositoryToken(ReviewItem),
          useValue: mockReviewRepository,
        },
      ],
    }).compile();

    service = module.get<HumanReviewService>(HumanReviewService);
    reviewRepository = module.get<Repository<ReviewItem>>(
      getRepositoryToken(ReviewItem)
    );

    jest.clearAllMocks();
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('queueForReview', () => {
    it('should create review item with URGENT priority for CRITICAL flags', async () => {
      const questionData = {
        questionId: 'q-123',
        questionText: '2 + 2 = ?',
        correctAnswer: '4',
      };

      const assessment: QualityAssessment = {
        confidenceScore: 0.5,
        appropriatenessScore: 0.6,
        educationalValue: 0.7,
        curriculumAlignment: 0.8,
        overallQuality: 0.65,
        reviewRequired: true,
        flags: [
          {
            type: 'INACCURATE',
            severity: 'CRITICAL',
            description: 'Mathematical error detected',
            autoGenerated: true,
          },
        ],
        metadata: {
          assessmentId: 'qa-001',
          timestamp: new Date(),
          assessmentDuration: 100,
          modelVersion: '1.0',
        },
      };

      const savedReview = {
        id: 'r-123',
        questionId: 'q-123',
        questionText: '2 + 2 = ?',
        correctAnswer: '4',
        qualityAssessment: assessment,
        priority: 'URGENT',
        reviewStatus: 'PENDING',
        createdAt: new Date(),
      };

      mockReviewRepository.create.mockReturnValue(savedReview);
      mockReviewRepository.save.mockResolvedValue(savedReview);

      const result = await service.queueForReview(questionData, assessment);

      expect(mockReviewRepository.create).toHaveBeenCalled();
      expect(mockReviewRepository.save).toHaveBeenCalled();
      expect(result.priority).toBe('URGENT');
      expect(result.reviewStatus).toBe('PENDING');
    });

    it('should create review item with HIGH priority for HIGH flags', async () => {
      const questionData = {
        questionId: 'q-456',
        questionText: '3 + 3 = ?',
        correctAnswer: '6',
      };

      const assessment: QualityAssessment = {
        confidenceScore: 0.7,
        appropriatenessScore: 0.7,
        educationalValue: 0.7,
        curriculumAlignment: 0.8,
        overallQuality: 0.725,
        reviewRequired: false,
        flags: [
          {
            type: 'CONFUSING',
            severity: 'HIGH',
            description: 'Explanation may confuse students',
            autoGenerated: true,
          },
        ],
        metadata: {
          timestamp: new Date(),
          modelVersion: '1.0',
          assessmentId: 'qa-001',
          assessmentDuration: 100,
        },
      };

      mockReviewRepository.create.mockReturnValue({});
      mockReviewRepository.save.mockResolvedValue({ priority: 'HIGH' });

      const result = await service.queueForReview(questionData, assessment);

      expect(result.priority).toBe('HIGH');
    });

    it('should create review item with HIGH priority for quality < 0.6', async () => {
      const questionData = {
        questionId: 'q-789',
        questionText: '5 - 2 = ?',
        correctAnswer: '3',
      };

      const assessment: QualityAssessment = {
        confidenceScore: 0.5,
        appropriatenessScore: 0.55,
        educationalValue: 0.6,
        curriculumAlignment: 0.6,
        overallQuality: 0.5625,
        reviewRequired: false,
        flags: [],
        metadata: {
          timestamp: new Date(),
          modelVersion: '1.0',
          assessmentId: 'qa-001',
          assessmentDuration: 100,
        },
      };

      mockReviewRepository.create.mockReturnValue({});
      mockReviewRepository.save.mockResolvedValue({ priority: 'HIGH' });

      const result = await service.queueForReview(questionData, assessment);

      expect(result.priority).toBe('HIGH');
    });

    it('should create review item with MEDIUM priority for quality between 0.6 and 0.8', async () => {
      const questionData = {
        questionId: 'q-101',
        questionText: '4 + 1 = ?',
        correctAnswer: '5',
      };

      const assessment: QualityAssessment = {
        confidenceScore: 0.75,
        appropriatenessScore: 0.7,
        educationalValue: 0.7,
        curriculumAlignment: 0.75,
        overallQuality: 0.725,
        reviewRequired: false,
        flags: [],
        metadata: {
          timestamp: new Date(),
          modelVersion: '1.0',
          assessmentId: 'qa-001',
          assessmentDuration: 100,
        },
      };

      mockReviewRepository.create.mockReturnValue({});
      mockReviewRepository.save.mockResolvedValue({ priority: 'MEDIUM' });

      const result = await service.queueForReview(questionData, assessment);

      expect(result.priority).toBe('MEDIUM');
    });

    it('should create review item with LOW priority for quality >= 0.8', async () => {
      const questionData = {
        questionId: 'q-202',
        questionText: '6 + 2 = ?',
        correctAnswer: '8',
      };

      const assessment: QualityAssessment = {
        confidenceScore: 0.9,
        appropriatenessScore: 0.85,
        educationalValue: 0.85,
        curriculumAlignment: 0.9,
        overallQuality: 0.875,
        reviewRequired: false,
        flags: [],
        metadata: {
          timestamp: new Date(),
          modelVersion: '1.0',
          assessmentId: 'qa-001',
          assessmentDuration: 100,
        },
      };

      mockReviewRepository.create.mockReturnValue({});
      mockReviewRepository.save.mockResolvedValue({ priority: 'LOW' });

      const result = await service.queueForReview(questionData, assessment);

      expect(result.priority).toBe('LOW');
    });
  });

  describe('getPendingReviews', () => {
    it('should retrieve pending reviews ordered by priority', async () => {
      const mockReviews = [
        {
          id: 'r-1',
          priority: 'URGENT',
          reviewStatus: 'PENDING',
          createdAt: new Date(),
        },
        {
          id: 'r-2',
          priority: 'HIGH',
          reviewStatus: 'PENDING',
          createdAt: new Date(),
        },
      ];

      mockReviewRepository.find.mockResolvedValue(mockReviews);

      const result = await service.getPendingReviews();

      expect(mockReviewRepository.find).toHaveBeenCalledWith({
        where: { reviewStatus: 'PENDING' },
        order: expect.any(Object),
      });
      expect(result).toHaveLength(2);
    });

    it('should return empty array if no pending reviews', async () => {
      mockReviewRepository.find.mockResolvedValue([]);

      const result = await service.getPendingReviews();

      expect(result).toEqual([]);
    });
  });

  describe('getReviewsByPriority', () => {
    it('should retrieve reviews filtered by priority level', async () => {
      const mockUrgentReviews = [
        {
          id: 'r-1',
          priority: 'URGENT',
          reviewStatus: 'PENDING',
        },
      ];

      mockReviewRepository.find.mockResolvedValue(mockUrgentReviews);

      const result = await service.getReviewsByPriority('URGENT');

      expect(mockReviewRepository.find).toHaveBeenCalledWith({
        where: {
          priority: 'URGENT',
          reviewStatus: 'PENDING',
        },
        order: { createdAt: 'ASC' },
      });
      expect(result).toHaveLength(1);
      expect(result[0].priority).toBe('URGENT');
    });
  });

  describe('assignReview', () => {
    it('should assign review to reviewer and update status to IN_REVIEW', async () => {
      const reviewId = 'r-123';
      const reviewerId = 'reviewer-456';

      const mockQueryBuilder = {
        update: jest.fn().mockReturnThis(),
        set: jest.fn().mockReturnThis(),
        where: jest.fn().mockReturnThis(),
        execute: jest.fn().mockResolvedValue({ affected: 1 }),
      };

      mockReviewRepository.createQueryBuilder.mockReturnValue(mockQueryBuilder);

      await service.assignReview(reviewId, reviewerId);

      expect(mockQueryBuilder.update).toHaveBeenCalled();
      expect(mockQueryBuilder.set).toHaveBeenCalledWith({
        reviewStatus: 'IN_REVIEW',
        reviewerId,
        reviewStartedAt: expect.any(Date),
      });
    });
  });

  describe('approveReview', () => {
    it('should mark review as approved with reviewer notes', async () => {
      const reviewId = 'r-123';
      const reviewerNotes = 'Content is accurate and age-appropriate';

      const mockQueryBuilder = {
        update: jest.fn().mockReturnThis(),
        set: jest.fn().mockReturnThis(),
        where: jest.fn().mockReturnThis(),
        execute: jest.fn().mockResolvedValue({ affected: 1 }),
      };

      mockReviewRepository.createQueryBuilder.mockReturnValue(mockQueryBuilder);

      await service.approveReview(reviewId, reviewerNotes);

      expect(mockQueryBuilder.set).toHaveBeenCalledWith({
        reviewStatus: 'APPROVED',
        reviewerNotes,
        reviewCompletedAt: expect.any(Date),
      });
    });
  });

  describe('rejectReview', () => {
    it('should mark review as rejected with rejection reason', async () => {
      const reviewId = 'r-123';
      const rejectionReason = 'Mathematical error in solution steps';

      const mockQueryBuilder = {
        update: jest.fn().mockReturnThis(),
        set: jest.fn().mockReturnThis(),
        where: jest.fn().mockReturnThis(),
        execute: jest.fn().mockResolvedValue({ affected: 1 }),
      };

      mockReviewRepository.createQueryBuilder.mockReturnValue(mockQueryBuilder);

      await service.rejectReview(reviewId, rejectionReason);

      expect(mockQueryBuilder.set).toHaveBeenCalledWith({
        reviewStatus: 'REJECTED',
        reviewerNotes: rejectionReason,
        reviewCompletedAt: expect.any(Date),
      });
    });
  });

  describe('getReviewStats', () => {
    it('should calculate review queue statistics', async () => {
      const mockQueryBuilder = {
        select: jest.fn().mockReturnThis(),
        addSelect: jest.fn().mockReturnThis(),
        where: jest.fn().mockReturnThis(),
        getRawOne: jest.fn().mockResolvedValue({
          totalPending: '25',
          urgentCount: '5',
          highCount: '10',
          mediumCount: '7',
          lowCount: '3',
        }),
      };

      mockReviewRepository.createQueryBuilder.mockReturnValue(mockQueryBuilder);

      const result = await service.getReviewStats();

      expect(result).toEqual({
        totalPending: 25,
        urgentCount: 5,
        highCount: 10,
        mediumCount: 7,
        lowCount: 3,
      });
    });

    it('should handle zero pending reviews', async () => {
      const mockQueryBuilder = {
        select: jest.fn().mockReturnThis(),
        addSelect: jest.fn().mockReturnThis(),
        where: jest.fn().mockReturnThis(),
        getRawOne: jest.fn().mockResolvedValue({
          totalPending: '0',
          urgentCount: '0',
          highCount: '0',
          mediumCount: '0',
          lowCount: '0',
        }),
      };

      mockReviewRepository.createQueryBuilder.mockReturnValue(mockQueryBuilder);

      const result = await service.getReviewStats();

      expect(result.totalPending).toBe(0);
    });
  });

  describe('getReviewById', () => {
    it('should retrieve review item by ID', async () => {
      const reviewId = 'r-123';
      const mockReview = {
        id: reviewId,
        questionId: 'q-123',
        priority: 'HIGH',
        reviewStatus: 'PENDING',
      };

      mockReviewRepository.findOne.mockResolvedValue(mockReview);

      const result = await service.getReviewById(reviewId);

      expect(mockReviewRepository.findOne).toHaveBeenCalledWith({
        where: { id: reviewId },
      });
      expect(result?.id).toBe(reviewId);
    });

    it('should return null if review not found', async () => {
      mockReviewRepository.findOne.mockResolvedValue(null);

      const result = await service.getReviewById('nonexistent-id');

      expect(result).toBeNull();
    });
  });

  describe('Performance', () => {
    it('should queue review in less than 100ms', async () => {
      const questionData = {
        questionId: 'q-999',
        questionText: '1 + 1 = ?',
        correctAnswer: '2',
      };

      const assessment: QualityAssessment = {
        confidenceScore: 0.9,
        appropriatenessScore: 0.9,
        educationalValue: 0.9,
        curriculumAlignment: 0.9,
        overallQuality: 0.9,
        reviewRequired: false,
        flags: [],
        metadata: {
          timestamp: new Date(),
          modelVersion: '1.0',
          assessmentId: 'qa-001',
          assessmentDuration: 100,
        },
      };

      mockReviewRepository.create.mockReturnValue({});
      mockReviewRepository.save.mockResolvedValue({});

      const start = Date.now();
      await service.queueForReview(questionData, assessment);
      const duration = Date.now() - start;

      expect(duration).toBeLessThan(100);
    });
  });
});
